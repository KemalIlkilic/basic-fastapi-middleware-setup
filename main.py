from collections import defaultdict
import time
from typing import Dict
from fastapi import FastAPI, Request
import random
import string

from starlette.responses import Response

app = FastAPI()

"""
A "middleware" is a function that works with every request before it is processed by any specific path operation.
And also with every response before returning it.
"""
@app.middleware("http")
async def request_id_logging(request : Request, call_next):
  """
  A function call_next that will receive the request as a parameter.
  This function will pass the request to the corresponding path operation.
  Then it returns the response generated by the corresponding path operation.
  """
  # Everything here runs BEFORE the route handler
  response = await call_next(request) # This is where the route handler executes
  # Everything here runs AFTER the route handler
  random_letters = ''.join(random.choice(string.ascii_letters) for _ in range(10))
  print(f"Log {random_letters}")
  response.headers["X-Request-ID"] = random_letters
  return response



from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
class AdvancedMiddleware(BaseHTTPMiddleware):
  #app: the ASGI application that this middleware will wrap
  # Middleware acts like a chain of handlers where each piece needs to know about the next piece.
  # The app parameter is what connects these pieces together.
  def __init__(self,app):
    super().__init__(app)
    #expected to be dictionary where the keys are (str) and the values are (float).
    self.rate_limit_records : Dict[str,float] = defaultdict(float)
  async def log_message(self,message : str):
    print(message)

  #middlewareâ€™s "main method" that runs for each request.
  async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:
    client_ip = request.client.host
    current_time = time.time()
    if current_time - self.rate_limit_records[client_ip] < 1: #1 request per second limit
      return Response(content="Rate limit exceeded", status_code=429)
    
    self.rate_limit_records[client_ip] = current_time
    path = request.url.path
    await self.log_message(f"Request to {path}")
    """
    "call_next"
    This is a callable (essentially a function) that represents the next part of the request-response cycle.
    It is what you call to pass the request along to the next middleware or to the actual endpoint
    if there is no other middleware.
    """
    #Let the request continue and await the response from the next handler
    response = await call_next(request)
    return response  # Send the response back to the client

app.add_middleware(AdvancedMiddleware)

@app.get("/")
async def say_hi():
  return "Hello Youtube"
